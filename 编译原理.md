# 编译原理笔记
## 上机
- 第 3，4，6，8，10，12 周
- 周一、周二晚任选
- 地点
    - 第 3, 4, 6 周
        - 周一 C201
        - 周二 C207、C211
    - 第 8, 10, 12 周 B204
---
第三章是考试重点

---
## 第二节
词法分析：把原始的字符串流形式的**程序文本**转换为**词法记号流**的形式。
### 词法单元与词法记号
* 词法单元：又称单词，是编程语言中*合法的字符串*。
* 词法记号：满足某种规则的词法单元，采用同一种记法。
* 满足一个 *给定规则（也称模式）* 的词法单元，被称为一个词法记号。
* 每个词法记号具有一定的含义（属性）。
* 语法分析使用词法记号，语义分析使用词法单元。
### 词法错误
* 恢复策略：紧急方式
### 语言的运算
* 指数：**L<sup>0</sup> 是空串**，L<sup>i</sup>=L<sup>i-1</sup>L
* 闭包：L<sup>*</sup> = L<sup>0</sup> U L<sup>1</sup> U L<sup>2</sup> U …… = L<sup>+</sup> U L<sup>0</sup>
* 正闭包：L<sup>+</sup> = L<sup>1</sup> U L<sup>2</sup> U ……
* 其实就是正则里面的 * 和 +。
### 正规式（正则表达式）
* 说明词法单元如何对应到词法记号的模式。
* 优先级：<sup>*+</sup>(闭包、正闭包) > 连接运算 > |(和)。
### 课后练习：
* 编写一个程序，用于统计文件中单词的个数与不同单词的个数。
---
## 第三节，第四节
### 词法记号的识别
- 等同于对字符串的匹配过程
- 可以基于*有限状态机*来完成
    - 单圈中间状态，双圈最终状态，双圈星号表示不处理退出。
    - > [有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。](https://zh.wikipedia.org/zh-hans/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)

### 有限自动机
计算机转换正规式的步骤  
正规式 => 不确定有限自动机 => 确定有限自动机 => 状态转换图

### 确定有限自动机 (DFA)
- 不允许空串
- 状态对某个字符最多有一个输出边
- 贴近计算机认识

### 不确定的有限自动机 (NFA)
- 允许输入空串
- **状态对某个字符可能有多个输出边**(与 DFA 的主要区分点)
- 贴近人类认识

```regex
(a|b)*ab
```

### 状态转移表
- *见课本*
- 表中所有状态转移集合只有一项的是 DFA

### DFA 构建方法
#### 自然语言描述 => DFA
1. 列出全部可能的状态
2. 从各个状态出发，构造边及输入字符记号

#### 正规式 => DFA

#### 正规式 => NFA => DFA (见课本)
1. NFA 构建
    1. 构造识别*空串*和*字母表中一个符号*的 NFA
    2. 构造识别主算符为*选择*的正规式的 NFA
    3. 构造识别主算符为*连接*的正规式的 NFA
    4. 构造识别主算符为*闭包*的正规式的 NFA
2. NFA => DFA 的转化
- 子集构造法（**看 PPT**）
    - DFA 的一个状态是 NFA 的一个状态集合
    1. 寻找所有等价状态
    2. 画出所有等价状态之间的状态转换图
1. DFA 化简（**看 PPT**)
- 状态的可区分性
- 化简时 DFA 的状态转换函数必须是一个*全函数*
    - 全函数：每个状态对字母表上每一个字母都有对应的输出边（自回环不算）

### 课后练习
- <del>字符串最多有两个1的01字符串正则表达式。</del>
```regex
^0*1?0*1?0*$
```
- <del>学习一下有限状态机的图形。</del>
- <del>构建识别能被 3 整除的二进制数的 DFA</del>
- <del>偶数个 0 偶数个 1 的正则表达式</del>
```regex
^(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*$
```
- <del>**(周五交)书上习题 2.3**</del>
- <del>编写识别 `(a|b)*ab` 的程序
    - 基于 DFA，用状态转移表格来做
    - 状态转移表的数据结构定义自选</del>
- <del>**(下周二交)2.7(c)(d), 2.8(仅为 2.7(c)), 2.12(a)**</del>
- <del>构造 DFA，接受 0 和 1 的个数都是偶数的二进制串</del>
---
## 第五节
### Flex
---
## 第六节
### 语法分析
- 目标：线性的词法记号流 => 语法树
- 实质：无结构的数据转化为有结构的数据
- 依据：上下文无关语法

### 上下文无关文法
- 最左推导
- 最右推导
- 二义性
- 分析树

---

## 第七节
### 自上而下分析
- 从根部开始构建语法树
- 存在问题
    - 存在左递归怎么办？
        - 不能因为左递归存在产生死循环
    - 一步推导有多个产生式可供选择，复杂的回溯
        - 每一步推导，可以选择的产生式必须是唯一的
#### 消除左递归
- 文法左递归
```
A => +Aα
```
- 直接左递归
    - 串的特点 βαααααα……
```
A => Aα|β
```
- **消除直接左递归**
```
A => βA'
A'=> αA' | ε
```

- 消除非直接左递归
    1. 先变换成直接左递归
    2. 再消除直接左递归

- **消除左递归的一般方法（看书）**

#### 提取左因子（看书）
- 当存在某一步推导可能有多种选择的产生式的时候，可通过提取左因子的方法修改文法

A => αβ<sub>1</sub> | αβ<sub>2</sub>

可以转换成

A => αA'

A'=> β<sub>1</sub> | β<sub>2</sub>

### 语言和文法
#### 非上下文无关的语言结构

---

## 第八节

### 文法类型（看 PPT）（考）
### LL(1) 文法（看PPT）
- FIRST(α) 是从 α 推导出来的串的起始*终结符*的集合
    - 起始字符是 ε 也算
- FOLLOW(A) 是在所有句型中紧跟在 A 后面的*终结符*集合
    - 如果 A 就是最右符号，那么 `$` 属于 FOLLOW(A)
    - 如果后面的符号 B 不是终结符，就把 FIRST(B) - ε 加入 FOLLOW(B)
    - 计算（看 PPT）
        1. 计算 FIRST 集
        2. 加入 `$` 到 FOLLOW(S)
        3. 后续计算

- 任何两个产生式 A -> a | b 都满足下列条件
    - FIRST(a) 与 FIRST(b) 的交集为空
    - 如果 b => ε，则 FIRST(a) 与 FOLLOW(A) 为空

### 自上而下分析实现
#### 递归函数法
- 为每一个非终结符写一个分析过程
- 这些过程可能是递归的
#### 非递归的预测分析方法（看书）
#### 构造预测分析表（看书）
- A => α
    - 行：A 所在的行
    - 列：FIRST(α) 所在的列。如果 FIRST(α) = ε，填在 FOLLOW(A) 所在的列

---

## 第九节

### 预测分析的错误恢复
- 错误类型
    - 词法错误
    - 语法错误
    - 语义错误
    - 逻辑错误
- 非递归预测分析：采用紧急方式的错误恢复
    - 分析器每次抛弃一个输入记号，直到输入记号属于某个指定的同步记号集合为止
        - 同步记号集合
            - 把 FOLLOW(A) 的所有终结符放入非终结符 A 的同步记号集合
            - 把高层结构的开始符号加到低层结构的同步记号集合中
            - 把 FIRST(A) 的终结符加入 A 的同步记号集合
        - 如果非终结符可以产生空串，若出错时栈顶是这样的非终结符，则可以使用产生空串的产生式
        - 如果终结符在栈顶而不能匹配，弹出此终结符

---

## 第十节

### 自下而上分析

- 使用最右推导
- 仍然从左到右扫描

#### 概念

- 归约（reduce）：最右推导的逆过程
    - 查看当前符号是否是某个产生式的右部
- 句柄：（不正式定义）和某产生式右部匹配的子串
    - 正式定义：右句型 $\gamma$ 的句柄是一个产生式的右部 $\beta$，并且该句柄 $\beta$ 在用 A 替换 $\gamma$ 中的句柄 $\beta$ 之后，得到的是最右推导中的前一个句型
        - 其实是最右推导反过来看
    - 右边仅含终结符（因为是最右推导的逆过程）
    - 如果文法二义，那么句柄可能不唯一
    - 在移进-规约分析中，句柄总是出现在栈顶
- 移进（shift）

#### 用栈实现移进-规约分析

- 四种动作
    - 移进
    - 归约
    - 接受
    - 报错
- 冲突
    - 移进-归约冲突
    - 归约-归约冲突

#### LR 分析器

- 处理的是一类 LR(k) 文法
    - k：决定分析动作时向前看的符号个数

- 简单的 LR 方法（SLR）
- 规范的 LR 方法
- 向前看的 LR 方法（LALR）

---

## 第十一节

### LR 分析表的构建

- 格局（Configuration）
    - 二元组表示 (栈的内容，尚未处理的输入)
        - $(s_0X_1s_2X_2s_2...X_ms_m, a_ia_{i+1}a_{i+2}...\$)$
- 移进查看 Action 表决定状态，归约查看 Goto 表决定状态
- Goto 表查询不可能出错

### 活前缀

- 右句型的前缀，该前缀不超过最右句柄的右端
    - S=>$^*_{rm}\gamma Aw$=>$_{rm}\gamma\beta w$
        - $\gamma \beta$ 的任何前缀（包括本身）都是一个活前缀
    - 栈中出现的串一定都是活前缀
        - 因为一旦出现句柄就进行归约了
- 活前缀可以用一个 DFA 来识别

### LR(0) 项目集

- 由一些 LR(0) 项目组成的集合

#### LR(0) 项目

- 在右部的某个地方加点的产生式
    - ·：希望（hope）
        - 左边：已看到的部分
        - 右边：希望看到的部分
        - 出现在
            - 产生式中间：移进
            - 产生式末尾：归约
    - 例如对于产生式 A->XYZ，加点项有
        - A->·XYZ
        - A->X·YZ
        - A->XY·Z
        - A->XYZ·
    - **例如对于产生式 A->$\epsilon$ 加点项有**
        - A->·

### 构造识别活前缀的 DFA

#### 1. 拓广文法
假设 S 是文法的开始符号，则追加 S<sup>'</sup>->S

#### 2. 构造 LR(0) 项目集规范族（看 PPT）

> 族：集合的同义词

- 闭包函数 $closure(I)$
    1. $I$ 的每个项目均加入 $closure(I)$
    2. 如果 A-> $\alpha·B\beta$ 在 $closure(I)$ 中，且 B->$\gamma$ 是产生式，那么如果项目 B->·$\gamma$ 还不在 $closure(I)$ 中的话，那么把它加入

---

## 第十二节

### 有效项目
- 如果 S'=>$^*_{rm} \alpha A \omega$=>$_{rm} \alpha\beta_{1}\beta_2\omega$，那么项目 A->$\beta_1·\beta_2$ 对活前缀 $\alpha\beta_1$ 是有效的
    - 一个项目可能对好几个活前缀都是有效的
    - 一个活前缀可能有多个有效项目

### 基于 DFA 构建分析表

#### 填表规则（见 PPT）

1. 如果 A-> $\alpha·a\beta$ 在 I<sub>i</sub> 中，并且 goto(I<sub>i</sub>, a) = I<sub>j</sub>，那么置 action(i, a) 为 sj
2. 如果 A->$\alpha$· 在 I<sub>i</sub> 中，那么对 FOLLOW(A) 中的所有 a，置 action[i, a] 为 rj，j 是产生式 A->$\alpha$ 的编号
3. 如果 S'->S· 在 I<sub>i</sub> 中，那么置 action[i, $] 为接受 acc
