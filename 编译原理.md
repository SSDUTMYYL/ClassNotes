# 编译原理笔记
## 上机
- 第 3，4，6，8，10，12 周
- 周一、周二晚任选
- 地点
    - 第 3, 4, 6 周
        - 周一 C201
        - 周二 C207、C211
    - 第 8, 10, 12 周 B204
---
第三章是考试重点

---
## 第二节
词法分析：把原始的字符串流形式的**程序文本**转换为**词法记号流**的形式。
### 词法单元与词法记号
* 词法单元：又称单词，是编程语言中*合法的字符串*。
* 词法记号：满足某种规则的词法单元，采用同一种记法。
* 满足一个 *给定规则（也称模式）* 的词法单元，被称为一个词法记号。
* 每个词法记号具有一定的含义（属性）。
* 语法分析使用词法记号，语义分析使用词法单元。
### 词法错误
* 恢复策略：紧急方式
### 语言的运算
* 指数：**L<sup>0</sup> 是空串**，L<sup>i</sup>=L<sup>i-1</sup>L
* 闭包：L<sup>*</sup> = L<sup>0</sup> U L<sup>1</sup> U L<sup>2</sup> U …… = L<sup>+</sup> U L<sup>0</sup>
* 正闭包：L<sup>+</sup> = L<sup>1</sup> U L<sup>2</sup> U ……
* 其实就是正则里面的 * 和 +。
### 正规式（正则表达式）
* 说明词法单元如何对应到词法记号的模式。
* 优先级：<sup>*+</sup>(闭包、正闭包) > 连接运算 > |(和)。
### 课后练习：
* 编写一个程序，用于统计文件中单词的个数与不同单词的个数。
---
## 第三节，第四节
### 词法记号的识别
- 等同于对字符串的匹配过程
- 可以基于*有限状态机*来完成
    - 单圈中间状态，双圈最终状态，双圈星号表示不处理退出。
    - > [有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。](https://zh.wikipedia.org/zh-hans/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)

### 有限自动机
计算机转换正规式的步骤  
正规式 => 不确定有限自动机 => 确定有限自动机 => 状态转换图

### 确定有限自动机 (DFA)
- 不允许空串
- 状态对某个字符最多有一个输出边
- 贴近计算机认识

### 不确定的有限自动机 (NFA)
- 允许输入空串
- **状态对某个字符可能有多个输出边**(与 DFA 的主要区分点)
- 贴近人类认识

```regex
(a|b)*ab
```

### 状态转移表
- *见课本*
- 表中所有状态转移集合只有一项的是 DFA

### DFA 构建方法
#### 自然语言描述 => DFA
1. 列出全部可能的状态
2. 从各个状态出发，构造边及输入字符记号

#### 正规式 => DFA

#### 正规式 => NFA => DFA (见课本)
1. NFA 构建
    1. 构造识别*空串*和*字母表中一个符号*的 NFA
    2. 构造识别主算符为*选择*的正规式的 NFA
    3. 构造识别主算符为*连接*的正规式的 NFA
    4. 构造识别主算符为*闭包*的正规式的 NFA
2. NFA => DFA 的转化
- 子集构造法（**看 PPT**）
    - DFA 的一个状态是 NFA 的一个状态集合
    1. 寻找所有等价状态
    2. 画出所有等价状态之间的状态转换图
1. DFA 化简（**看 PPT**)
- 状态的可区分性
- 化简时 DFA 的状态转换函数必须是一个*全函数*
    - 全函数：每个状态对字母表上每一个字母都有对应的输出边（自回环不算）

### 课后练习
- <del>字符串最多有两个1的01字符串正则表达式。</del>
```regex
^0*1?0*1?0*$
```
- <del>学习一下有限状态机的图形。</del>
- <del>构建识别能被 3 整除的二进制数的 DFA</del>
- <del>偶数个 0 偶数个 1 的正则表达式</del>
```regex
^(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*$
```
- <del>**(周五交)书上习题 2.3**</del>
- <del>编写识别 `(a|b)*ab` 的程序
    - 基于 DFA，用状态转移表格来做
    - 状态转移表的数据结构定义自选</del>
- <del>**(下周二交)2.7(c)(d), 2.8(仅为 2.7(c)), 2.12(a)**</del>
- <del>构造 DFA，接受 0 和 1 的个数都是偶数的二进制串</del>
---
## 第五节
### Flex
---
## 第六节
### 语法分析
- 目标：线性的词法记号流 => 语法树
- 实质：无结构的数据转化为有结构的数据
- 依据：上下文无关语法

### 上下文无关文法
- 最左推导
- 最右推导
- 二义性
- 分析树

---

## 第七节
### 自上而下分析
- 从根部开始构建语法树
- 存在问题
    - 存在左递归怎么办？
        - 不能因为左递归存在产生死循环
    - 一步推导有多个产生式可供选择，复杂的回溯
        - 每一步推导，可以选择的产生式必须是唯一的
#### 消除左递归
- 文法左递归
```
A => +Aα
```
- 直接左递归
    - 串的特点 βαααααα……
```
A => Aα|β
```
- **消除直接左递归**
```
A => βA'
A'=> αA' | ε
```

- 消除非直接左递归
    1. 先变换成直接左递归
    2. 再消除直接左递归

- **消除左递归的一般方法（看书）**

#### 提取左因子（看书）
- 当存在某一步推导可能有多种选择的产生式的时候，可通过提取左因子的方法修改文法

A => αβ<sub>1</sub> | αβ<sub>2</sub>

可以转换成

A => αA'

A'=> β<sub>1</sub> | β<sub>2</sub>

### 语言和文法
#### 非上下文无关的语言结构

---

## 第八节

### 文法类型（看 PPT）（考）
### LL(1) 文法（看PPT）
- FIRST(α) 是从 α 推导出来的串的起始*终结符*的集合
    - 起始字符是 ε 也算
- FOLLOW(A) 是在所有句型中紧跟在 A 后面的*终结符*集合
    - 如果 A 就是最右符号，那么 `$` 属于 FOLLOW(A)
    - 如果后面的符号 B 不是终结符，就把 FIRST(B) - ε 加入 FOLLOW(B)
    - 计算（看 PPT）
        1. 计算 FIRST 集
        2. 加入 `$` 到 FOLLOW(S)
        3. 后续计算

- 任何两个产生式 A -> a | b 都满足下列条件
    - FIRST(a) 与 FIRST(b) 的交集为空
    - 如果 b => ε，则 FIRST(a) 与 FOLLOW(A) 为空

### 自上而下分析实现
#### 递归函数法
- 为每一个非终结符写一个分析过程
- 这些过程可能是递归的
#### 非递归的预测分析方法（看书）
#### 构造预测分析表（看书）
- A => α
    - 行：A 所在的行
    - 列：FIRST(α) 所在的列。如果 FIRST(α) = ε，填在 FOLLOW(A) 所在的列

---

## 第九节

### 预测分析的错误恢复
- 错误类型
    - 词法错误
    - 语法错误
    - 语义错误
    - 逻辑错误
- 非递归预测分析：采用紧急方式的错误恢复
    - 分析器每次抛弃一个输入记号，直到输入记号属于某个指定的同步记号集合为止
        - 同步记号集合
            - 把 FOLLOW(A) 的所有终结符放入非终结符 A 的同步记号集合
            - 把高层结构的开始符号加到低层结构的同步记号集合中
            - 把 FIRST(A) 的终结符加入 A 的同步记号集合
        - 如果非终结符可以产生空串，若出错时栈顶是这样的非终结符，则可以使用产生空串的产生式
        - 如果终结符在栈顶而不能匹配，弹出此终结符

---

## 第十节

### 自下而上分析

- 使用最右推导
- 仍然从左到右扫描

#### 概念

- 归约（reduce）：最右推导的逆过程
    - 查看当前符号是否是某个产生式的右部
- 句柄：（不正式定义）和某产生式右部匹配的子串
    - 正式定义：右句型 $\gamma$ 的句柄是一个产生式的右部 $\beta$，并且该句柄 $\beta$ 在用 A 替换 $\gamma$ 中的句柄 $\beta$ 之后，得到的是最右推导中的前一个句型
        - 其实是最右推导反过来看
    - 右边仅含终结符（因为是最右推导的逆过程）
    - 如果文法二义，那么句柄可能不唯一
    - 在移进-规约分析中，句柄总是出现在栈顶
- 移进（shift）

#### 用栈实现移进-规约分析

- 四种动作
    - 移进
    - 归约
    - 接受
    - 报错
- 冲突
    - 移进-归约冲突
    - 归约-归约冲突

#### LR 分析器

- 处理的是一类 LR(k) 文法
    - k：决定分析动作时向前看的符号个数

- 简单的 LR 方法（SLR）
- 规范的 LR 方法
- 向前看的 LR 方法（LALR）

---

## 第十一节

### LR 分析表的构建

- 格局（Configuration）
    - 二元组表示 (栈的内容，尚未处理的输入)
        - $(s_0X_1s_2X_2s_2...X_ms_m, a_ia_{i+1}a_{i+2}...\$)$
- 移进查看 Action 表决定状态，归约查看 Goto 表决定状态
- Goto 表查询不可能出错

### 活前缀

- 右句型的前缀，该前缀不超过最右句柄的右端
    - S=>$^*_{rm}\gamma Aw$=>$_{rm}\gamma\beta w$
        - $\gamma \beta$ 的任何前缀（包括本身）都是一个活前缀
    - 栈中出现的串一定都是活前缀
        - 因为一旦出现句柄就进行归约了
- 活前缀可以用一个 DFA 来识别

### LR(0) 项目集

- 由一些 LR(0) 项目组成的集合

#### LR(0) 项目

- 在右部的某个地方加点的产生式
    - ·：希望（hope）
        - 左边：已看到的部分
        - 右边：希望看到的部分
        - 出现在
            - 产生式中间：移进
            - 产生式末尾：归约
    - 例如对于产生式 A->XYZ，加点项有
        - A->·XYZ
        - A->X·YZ
        - A->XY·Z
        - A->XYZ·
    - **例如对于产生式 A->$\epsilon$ 加点项有**
        - A->·

### 构造识别活前缀的 DFA

#### 1. 拓广文法
假设 S 是文法的开始符号，则追加 S<sup>'</sup>->S

#### 2. 构造 LR(0) 项目集规范族（看 PPT）

> 族：集合的同义词

- 闭包函数 $closure(I)$
    1. $I$ 的每个项目均加入 $closure(I)$
    2. 如果 A-> $\alpha·B\beta$ 在 $closure(I)$ 中，且 B->$\gamma$ 是产生式，那么如果项目 B->·$\gamma$ 还不在 $closure(I)$ 中的话，那么把它加入

---

## 第十二节

### 有效项目
- 如果 S'=>$^*_{rm} \alpha A \omega$=>$_{rm} \alpha\beta_{1}\beta_2\omega$，那么项目 A->$\beta_1·\beta_2$ 对活前缀 $\alpha\beta_1$ 是有效的
    - 一个项目可能对好几个活前缀都是有效的
    - 一个活前缀可能有多个有效项目

### 基于 DFA 构建分析表

#### 填表规则（见 PPT）

1. 如果 A-> $\alpha·a\beta$ 在 I<sub>i</sub> 中，并且 goto(I<sub>i</sub>, a) = I<sub>j</sub>，那么置 action(i, a) 为 sj
2. 如果 A->$\alpha$· 在 I<sub>i</sub> 中，那么对 FOLLOW(A) 中的所有 a，置 action[i, a] 为 rj，j 是产生式 A->$\alpha$ 的编号
3. 如果 S'->S· 在 I<sub>i</sub> 中，那么置 action[i, $] 为接受 acc

- 通过 DFA 就可填出移进以及状态转移
- 归约规则填写规则：·在产生式右侧最右边，而且表格中非终结符在 FOLLOW 集合中，状态在 GOTO 表中
---

## 第十三节

### LR(1) 文法

- 与 SLR(1) 文法的区别
    - 项目集的定义发生了改变

#### 前向搜索符

- 一个项目 A->$\alpha · \beta$，如果最终用这个产生式进行归约之后，期望看见的符号是 a，则这个加点项的前项搜索符是 a
- 上述项目可写成 A->$\alpha·\beta, a$，即为 LR(1) 项目
- 搜索符在 · 到达产生式最右侧时才有用，用于表示遇到哪个终结符时进行归约
- 取代 SLR 中 FOLLOW 集的作用，一般是 FOLLOW 集合的一个子集

#### 加前向搜索符

1. 初始项目集 I<sub>0</sub>：[S'->·S, $] 将 $ 作为向前的搜索符
2. 计算闭包 $closure(I)$

(a) I 中的任何项目都属于 $closure(I)$

(b) 若有项目 [A->$\alpha·B\beta,a$] 在 $closure(I)$ 中，而 B->$\gamma$ 是文法中的产生式，b 是 FIRST($\beta a$) 中的元素，则 [B->·$\gamma,b$] 也属于 $closure(I)$

(c) 只有求闭包的时候才修改搜索符

#### 根据 LR(1) 项目来构造识别 G' 活前缀的 DFA（见 PPT）

### LALR

- 合并识别 LR(1) 文法的活前缀的 DFA 中的同心项目集
- 合并可能会引起冲突
    - 不会带来新的移进-归约冲突
    - 可能打开新的归约-归约冲突

> 同心项目集：仅有搜索符不同的 LR(1) 文法项

---

## 第十三节

### LR 文法和 LR 分析方法的特点

- 栈中的文法符号总是形成一个活前缀
- 分析表的转移函数本质上是识别活前缀的 DFA
- 栈顶的状态符号包含了确定句柄所需要的一切信息
- 是已知的最一般的无回溯的移进-归约方法
- 能分析的文法类是预测分析法能分析的文法类的真超集
- 能及时发现语法错误
- 缺点
    - 手工构造分析表的工作量太大

||LR(1) 方法|LL(1) 方法|
|:--|:--:|:--:|
|建立分析树的方式|自下而上|自上而下|
|归约还是推导|规范归约|最左推导|
|决定使用产生式的时机|看见产生式整个右部推出的东西后才算是看准了用哪个产生式进行归约|看见产生式右部推出的第一个终结符后便确定用哪个产生式进行推导|
|对文法的显式限制|对文法没有限制|无左递归、公共左因子|
|分析表|状态$\times$文法符号 分析表大|分析表小|

### LR 分析的错误恢复

#### 出错情况

- 访问动作表时遇到出错条目
    - 访问转移表时不会遇到出错条目
        - 因为出错的是输入的终结符，非终结符一定是归约得到的，而出现归约代表输入一定是正确的

#### 紧急方式错误恢复

- 退栈，直至出现状态 s，它有预先确定的 A 的转移
- 抛弃若干个输入符号，只要找到 a，它是 A 的合法后继
- 再把 A 和 goto[s, A] 压进栈，恢复正常分析

#### 非 LR 的上下文无关结构

#### Yacc

---

## 第十四节

### 语义分析

- 编译程序的目标：将源程序翻译成为**语义等价**的目标程序
    - 源程序与目标程序具有不同的语法结构，表达的结果却是相同的
- 语义分析的功能
    - 审查每个语法结构的静态语义
        - 例：类型、运算、维数、越界
    - 在验证完静态语义后，才执行真正的翻译
        - 例：变量的存储分配、表达式的求值、语句的翻译（中间代码的生成）
- 语义规则和产生式相联系的两种方式
    - 语法制导定义
    - 语法制导的翻译方案
- 语义信息是上下文有关的
    - 例：变量使用要先定义
- 目前情况
    - 上下文无关文法
        - 能够有效描述语法结构
        - 具有有效的分析方法
    - 程序语义
        - 编译器进行翻译时必要的信息
        - 无法用上下文无关文法表示
    - 衔接：属性文法
        - 在上下文无关文法基础上，为每个文法符号（终结符或非终结符）配备若干“值”（称为属性）
        - 属性代表文法符号相关信息，如类型、值

### 属性文法

- 语法制导定义：带属性和规则的上下文无关文法
- 基础文法
    - 综合属性
    - 继承属性
        - 由此结点的父结点和/或兄弟结点的某些属性决定
- 关于属性
    - 终结符只有综合属性，并且这些综合属性通常由词法分析器提供
    - 非终结符既有综合属性也可有继承属性，文法的开始符号没有继承属性（因为没有父结点或者是兄弟结点），除非另外加以说明
    - 对出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性
    - 出现在产生式左边的继承属性和出现在产生式右边的综合属性不由所给的产生式的属性计算规则进行计算，它们由其他产生式的属性规则计算或者由属性计算器的参数提供

---

## 第十六节

### 综合属性

- S 属性：仅仅使用综合属性的语法制导定义

### 继承属性

- 由父节点或兄弟结点的属性决定

### 语法制导

- 综合属性计算可以自上而下或自下而上完成
    - 自上而下：通过递归逐级返回
    - 自下而上：在原来分析算法基础上增加*属性栈*，同步弹栈入站，边分析边计算
- 继承属性计算
    - 自上而下：继承属性当做参数传递下去
    - 自下而上：属性需要在开始分析之前就传递过去

例如对于以下文法，L 的变量类型继承属性就需要在 L 开始分析之前就传递过去；L<sub>1</sub> 的类型属性也需要在 L<sub>1</sub> 开始分析之前就从父节点传递过来

- $T\rightarrow TL$
- $T\rightarrow int$
- $T\rightarrow real$
- $L\rightarrow L_1, id$
- $L\rightarrow id$
   
但是也不能做到太早传递，例如在 $T\rightarrow TLM$，不可能在 T 之后立即传递属性给 M

### 属性依赖图

- 有向图，表示分析树结点的继承属性和综合属性之间的相互依赖关系
- 如果属性 b 依赖于属性 c，则画从 c 到 b 的有向线（可理解成 b 从 c 来）
- 拓扑排序：结点的一种排序，使得边只会从该次序中先出现的结点到后出现的结点
    - 其实就是保证后边的结点所依赖的属性都已经有了
- 良定义：一个属性文法不存在属性之间的循环依赖关系，那么称该文法为良定义的

### 语法树（看 PPT）

分析树的浓缩表示，算符和关键字作为内部结点。

#### 建立

- `mknode(op, left, right)`
    - 建立一个运算符号结点，标号是 `op`，两个域指向左子树和右子树
- `mkleaf(id, entry)`
    - 建立一个标识符结点，标号是 `id`，符号表入口是 `entry`
- `mkleaf(num, val)`
    - 建立数结点，标号为 `num`，值为 `val`